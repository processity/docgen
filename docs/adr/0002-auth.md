# ADR 0002: Authentication Strategy

**Status**: Accepted
**Date**: 2025-11-05
**Decision Makers**: Security Team, Architecture Team

## Context

The service requires secure bi-directional communication:
1. **Inbound**: Salesforce → Node API (interactive and batch requests)
2. **Outbound**: Node → Salesforce (template fetch, file upload, status updates)

We must ensure:
- No secrets in Apex code
- Least-privilege access
- Token refresh and caching
- Compliance with enterprise security standards

## Decision

We will implement **dual authentication**:

### Inbound: Azure AD (Entra ID) OAuth2 Client Credentials
**Direction**: Salesforce → Node
**Mechanism**: AAD JWT Bearer tokens via Salesforce Named Credential

**How it Works**:
1. Salesforce Named Credential configured with AAD client credentials
2. Salesforce automatically obtains access token from AAD
3. Token sent as `Authorization: Bearer <token>` header
4. Node validates JWT using AAD's OpenID Connect metadata (JWKS)

**Validation Checks**:
- `iss` (issuer) = `https://sts.windows.net/<TENANT_ID>/`
- `aud` (audience) = Node's client ID
- `exp` (expiry) and `nbf` (not before) within valid range
- Signature verification using cached JWKS keys

### Outbound: Salesforce JWT Bearer Flow
**Direction**: Node → Salesforce
**Mechanism**: Server-to-server JWT authentication with Integration User

**How it Works**:
1. Node signs JWT using private key (from Azure Key Vault)
2. JWT contains:
   - `iss` = Connected App Consumer Key
   - `aud` = `https://login.salesforce.com` (or sandbox equivalent)
   - `sub` = Integration User username
   - `exp` = 5 minutes from now
3. Exchange JWT for access token via `POST /services/oauth2/token`
4. Cache token until expiry; refresh on 401

**Integration User Permissions** (Least Privilege):
- `ContentVersion`: Create, Read
- `ContentDocument`: Read
- `ContentDocumentLink`: Create
- `Docgen_Template__c`: Read
- `Generated_Document__c`: Read, Update
- **No** broad object CRUD beyond these

## Alternatives Considered

### Alternative 1: Username/Password Flow
**Rejected**: Storing passwords is insecure and violates security best practices. No support for MFA.

### Alternative 2: Salesforce-to-Salesforce (S2S) Auth
**Rejected**: Not applicable - Node is external system, not another Salesforce org.

### Alternative 3: API Keys
**Rejected**: Less secure than OAuth2, no built-in expiry, rotation is manual.

### Alternative 4: Mutual TLS (mTLS)
**Considered but not adopted**: Adds certificate management complexity. AAD + JWT provides sufficient security with better Azure integration.

## Consequences

### Positive
- **No secrets in Apex**: Credentials managed by Salesforce Named Credential and Azure Key Vault
- **Automatic token refresh**: Both directions handle expiry gracefully
- **Fine-grained permissions**: Integration User has minimal required access
- **Audit trail**: All Salesforce API calls tied to Integration User
- **Enterprise-grade**: AAD provides enterprise SSO, MFA, conditional access

### Negative
- **Setup complexity**: Requires AAD app registration, Connected App, and Key Vault configuration
- **Token caching**: Must implement proper cache invalidation on 401
- **Key rotation**: Private key rotation requires deployment

### Security Considerations
1. **Private Key Storage**: Never commit to source control; fetch from Key Vault at startup
2. **Token Scope**: AAD token scoped only to this API's client ID
3. **HTTPS Only**: All communication over TLS 1.2+
4. **Correlation IDs**: Track all auth events for forensic analysis

## Implementation Notes

### Inbound (AAD) Validation
```typescript
// Pseudo-code
const jwksClient = new JwksClient({ uri: `https://login.microsoftonline.com/${tenantId}/v2.0/.well-known/openid-configuration` });
const decoded = jwt.verify(token, getKey, {
  audience: clientId,
  issuer: `https://sts.windows.net/${tenantId}/`,
});
```

### Outbound (Salesforce JWT)
```typescript
// Pseudo-code
const payload = {
  iss: connectedAppClientId,
  aud: 'https://login.salesforce.com',
  sub: integrationUserUsername,
  exp: Math.floor(Date.now() / 1000) + 300,
};
const token = jwt.sign(payload, privateKey, { algorithm: 'RS256' });
// Exchange for access token...
```

### Token Caching Strategy
- **AAD JWKS**: Cache signing keys for 24 hours
- **Salesforce Access Token**: Cache until expiry (typically 2 hours)
- **Refresh on 401**: Automatic retry with new token

## Configuration Requirements

### Azure AD App Registration
- Client ID for Node API
- Redirect URI: Not required (client credentials flow)
- Permissions: None (API is the resource)

### Salesforce Named Credential
- Type: Named Principal
- Identity Type: Per User
- Authentication Protocol: OAuth 2.0
- OAuth Client ID: AAD app client ID
- OAuth Client Secret: AAD app client secret
- Token Endpoint: `https://login.microsoftonline.com/<tenant>/oauth2/v2.0/token`

### Salesforce Connected App
- OAuth Scopes: `api`, `refresh_token`, `offline_access`
- Permitted Users: Integration User only
- IP Relaxation: Enable (or whitelist Azure Container Apps IPs)

## References

- [Azure AD OAuth 2.0 Client Credentials Flow](https://learn.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-client-creds-grant-flow)
- [Salesforce JWT Bearer Flow](https://help.salesforce.com/s/articleView?id=sf.remoteaccess_oauth_jwt_flow.htm)
- [Salesforce Named Credentials](https://help.salesforce.com/s/articleView?id=sf.named_credentials_about.htm)
- Development Context: `development-context.md` Sections 6, 9
