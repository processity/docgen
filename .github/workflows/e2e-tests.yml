name: E2E Tests

on:
  pull_request:
    branches: [main]
  workflow_dispatch:  # Allow manual trigger

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true  

jobs:
  e2e-tests:
    name: Setup Org, Deploy Backend, and Run E2E Tests
    runs-on: ubuntu-latest
    timeout-minutes: 60
    environment: ci

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Install Salesforce CLI
        run: npm install -g @salesforce/cli

      - name: Authenticate Dev Hub
        env:
          SFDX_AUTH_URL: ${{ secrets.SFDX_AUTH_URL }}
        run: |
          echo "$SFDX_AUTH_URL" > auth.txt
          sf org login sfdx-url --sfdx-url-file auth.txt --alias devhub --set-default-dev-hub
          rm auth.txt

      - name: Create scratch org
        id: create-org
        run: |
          ORG_ALIAS="e2e-test-${{ github.run_number }}"
          echo "org_alias=${ORG_ALIAS}" >> $GITHUB_OUTPUT

          sf org create scratch \
            --definition-file config/project-scratch-def.json \
            --alias ${ORG_ALIAS} \
            --set-default \
            --duration-days 1 \
            --wait 10 \
            --json > org-create.json

          # Check if creation succeeded
          if [ $(jq -r '.status' org-create.json) -eq 0 ]; then
            echo "‚úÖ Scratch org created successfully"
          else
            echo "‚ùå Failed to create scratch org"
            cat org-create.json
            exit 1
          fi

      - name: Deploy Salesforce metadata
        run: |
          sf project deploy start --source-dir force-app --wait 10
          echo "‚úÖ Metadata deployed"

      - name: Configure External Credential with AAD secrets
        id: apex-config
        continue-on-error: true
        env:
          AAD_CLIENT_ID: ${{ secrets.AAD_CLIENT_ID }}
          AAD_CLIENT_SECRET: ${{ secrets.AAD_CLIENT_SECRET }}
        run: |
          echo "Configuring External Credential with AAD client credentials..."

          # Use the configure-external-credential.sh script with CI environment
          ./scripts/configure-external-credential.sh docgen-dev CI "$AAD_CLIENT_ID" "$AAD_CLIENT_SECRET"

          if [ $? -eq 0 ]; then
            echo "‚úÖ External Credential configured successfully"
          else
            echo "‚ö†Ô∏è  External Credential configuration failed"
            exit 1
          fi

      - name: Assign permission set
        run: |
          sf org assign permset --name Docgen_User

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set Azure Subscription
        run: az account set --subscription ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Ensure CI Resource Group exists
        run: |
          if ! az group show --name docgen-ci-rg &>/dev/null; then
            echo "Creating resource group docgen-ci-rg..."
            az group create \
              --name docgen-ci-rg \
              --location eastus \
              --tags \
                Environment=ci \
                Project=Salesforce-Docgen \
                Purpose=E2E-Testing \
                ManagedBy=GitHub-Actions
            echo "‚úÖ Resource group created"
          else
            echo "‚úÖ Resource group already exists"
          fi

      - name: Build and push Docker image
        run: |
          echo "üèóÔ∏è Building and pushing CI Docker image..."

          # Login to ACR
          az acr login --name ${{ secrets.ACR_NAME }}

          # Build and push image with ci-specific tag
          IMAGE_TAG="ci-${{ github.sha }}"
          docker build -t ${{ secrets.ACR_NAME }}.azurecr.io/docgen-api:${IMAGE_TAG} .
          docker push ${{ secrets.ACR_NAME }}.azurecr.io/docgen-api:${IMAGE_TAG}

          echo "‚úÖ Docker image built and pushed"
          echo "IMAGE_TAG=${IMAGE_TAG}" >> $GITHUB_ENV

      - name: Deploy CI backend infrastructure
        run: |
          echo "üöÄ Deploying CI backend infrastructure..."

          az deployment group create \
            --resource-group docgen-ci-rg \
            --template-file infra/main.bicep \
            --parameters infra/parameters/ci.bicepparam \
            --parameters imageTag=${{ env.IMAGE_TAG }} \
            --mode Incremental \
            --output json > deployment-output.json

          echo "‚úÖ CI backend infrastructure deployed"

          # Extract and save backend URL
          APP_FQDN=$(az containerapp show \
            --name docgen-ci \
            --resource-group docgen-ci-rg \
            --query properties.configuration.ingress.fqdn -o tsv)

          BACKEND_URL="https://${APP_FQDN}"
          echo "BACKEND_URL=${BACKEND_URL}" >> $GITHUB_ENV
          echo "üìç CI Backend URL: ${BACKEND_URL}"

      - name: Populate CI Key Vault secrets
        run: |
          echo "üîê Populating CI Key Vault secrets..."

          KEY_VAULT_NAME="docgen-ci-kv"

          # Set SF private key (for Node -> Salesforce JWT Bearer flow)
          echo "${{ secrets.CI_SF_PRIVATE_KEY }}" | az keyvault secret set \
            --vault-name ${KEY_VAULT_NAME} \
            --name SF-PRIVATE-KEY \
            --value @/dev/stdin \
            --output none

          # Set SF client ID (Connected App)
          az keyvault secret set \
            --vault-name ${KEY_VAULT_NAME} \
            --name SF-CLIENT-ID \
            --value "${{ secrets.CI_SF_CLIENT_ID }}" \
            --output none

          # Set SF username (Integration User)
          az keyvault secret set \
            --vault-name ${KEY_VAULT_NAME} \
            --name SF-USERNAME \
            --value "${{ secrets.CI_SF_USERNAME }}" \
            --output none

          # Set SF domain
          az keyvault secret set \
            --vault-name ${KEY_VAULT_NAME} \
            --name SF-DOMAIN \
            --value "test.salesforce.com" \
            --output none

          # Set SFDX Auth URL (from earlier scratch org creation)
          SFDX_AUTH_URL=$(sf org display --verbose --json | jq -r '.result.sfdxAuthUrl')

          if [ -z "$SFDX_AUTH_URL" ] || [ "$SFDX_AUTH_URL" = "null" ]; then
            echo "‚ùå Failed to extract SFDX Auth URL from org"
            exit 1
          fi

          echo "$SFDX_AUTH_URL" | az keyvault secret set \
            --vault-name ${KEY_VAULT_NAME} \
            --name SFDX-AUTH-URL \
            --value @/dev/stdin \
            --output none

          # Set Azure Monitor connection string
          APP_INSIGHTS_CONN=$(az monitor app-insights component show \
            --resource-group docgen-ci-rg \
            --query '[0].connectionString' -o tsv)

          az keyvault secret set \
            --vault-name ${KEY_VAULT_NAME} \
            --name AZURE-MONITOR-CONNECTION-STRING \
            --value "${APP_INSIGHTS_CONN}" \
            --output none

          echo "‚úÖ CI Key Vault secrets populated (including scratch org SFDX Auth URL)"

      - name: Restart Container App to pick up all secrets
        run: |
          echo "üîÑ Restarting Container App to pick up all secrets..."

          az containerapp revision restart \
            --name docgen-ci \
            --resource-group docgen-ci-rg \
            --revision $(az containerapp revision list \
              --name docgen-ci \
              --resource-group docgen-ci-rg \
              --query '[0].name' -o tsv)

          echo "‚úÖ Container App restarted"
          echo "‚è≥ Waiting 30 seconds for secrets to propagate..."
          sleep 30

      - name: Install Playwright browsers
        run: npx playwright install chromium --with-deps

      - name: Get org credentials
        id: org-info
        run: |
          # Get org info (org is already authenticated and set as default)
          sf org display --json > org-info.json

          # Extract credentials and set as environment variables
          INSTANCE_URL=$(jq -r '.result.instanceUrl' org-info.json)
          ACCESS_TOKEN=$(jq -r '.result.accessToken' org-info.json)
          USERNAME=$(jq -r '.result.username' org-info.json)

          echo "SF_INSTANCE_URL=$INSTANCE_URL" >> $GITHUB_ENV
          echo "SF_ACCESS_TOKEN=$ACCESS_TOKEN" >> $GITHUB_ENV
          echo "SF_USERNAME=$USERNAME" >> $GITHUB_ENV

          echo "Instance URL: $INSTANCE_URL"
          echo "Username: $USERNAME"

      - name: Verify CI backend is healthy
        run: |
          echo "Verifying CI backend health at: ${BACKEND_URL}/readyz"

          MAX_ATTEMPTS=20
          ATTEMPT=0

          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            ATTEMPT=$((ATTEMPT + 1))
            echo "Attempt $ATTEMPT/$MAX_ATTEMPTS: Checking ${BACKEND_URL}/readyz"

            # Get HTTP status code
            HTTP_CODE=$(curl -s -o /tmp/readyz-response.json -w "%{http_code}" "${BACKEND_URL}/readyz")

            if [ "$HTTP_CODE" = "200" ]; then
              echo "‚úÖ Backend responded with HTTP 200"

              # Verify JSON response shows ready: true
              if jq -e '.ready == true' /tmp/readyz-response.json > /dev/null 2>&1; then
                echo "‚úÖ CI backend is healthy and ready (all dependencies OK)"
                cat /tmp/readyz-response.json | jq '.'
                exit 0
              else
                echo "‚ö†Ô∏è  Backend returned 200 but reports not ready:"
                cat /tmp/readyz-response.json | jq '.'
              fi
            else
              echo "Backend returned HTTP $HTTP_CODE (expected 200)"
            fi

            if [ $ATTEMPT -lt $MAX_ATTEMPTS ]; then
              echo "Retrying in 6 seconds..."
              sleep 6
            fi
          done

          echo "‚ùå CI backend failed health check after $MAX_ATTEMPTS attempts (2 minutes)"
          echo "Last response:"
          cat /tmp/readyz-response.json 2>/dev/null || echo "No response captured"
          exit 1

      - name: Run Playwright E2E tests
        run: npm run test:e2e
        env:
          CI: true
          BACKEND_URL: ${{ env.BACKEND_URL }}

      - name: Upload Playwright report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-report
          path: e2e/playwright-report/
          retention-days: 30

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: e2e/test-results/
          retention-days: 30

      - name: Delete scratch org
        if: always()
        run: |
          ORG_ALIAS="${{ steps.create-org.outputs.org_alias }}"
          sf org delete scratch \
            --target-org ${ORG_ALIAS} \
            --no-prompt || echo "Org already deleted or not found"

      - name: Comment PR with test results
        if: github.event_name == 'pull_request' && always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            // Read test results if available
            let testSummary = '## E2E Test Results\n\n';

            try {
              const reportPath = 'e2e/playwright-report/index.html';
              if (fs.existsSync(reportPath)) {
                testSummary += '‚úÖ Tests completed. View the [Playwright Report](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) for details.\n';
              } else {
                testSummary += '‚ö†Ô∏è Test report not found.\n';
              }
            } catch (error) {
              testSummary += '‚ùå Failed to read test results.\n';
            }

            // Comment on PR
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: testSummary
            });
