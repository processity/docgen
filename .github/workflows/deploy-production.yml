name: Deploy to Production

on:
  release:
    types: [created]
  workflow_dispatch:  # Allow manual trigger
    inputs:
      release_tag:
        description: 'Release tag (e.g., v1.0.0)'
        required: true
        type: string

concurrency:
  group: production-deployment
  cancel-in-progress: false  # Never cancel production deployments

env:
  AZURE_REGION: eastus

jobs:
  build-image:
    name: Build and Push Docker Image
    uses: ./.github/workflows/docker-build.yml
    with:
      environment: production
      image_tag: ${{ github.event.release.tag_name || inputs.release_tag }}
    secrets:
      AZURE_CREDENTIALS: ${{ secrets.AZURE_CREDENTIALS }}
      AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      ACR_NAME: ${{ secrets.ACR_NAME }}

  build-sha-image:
    name: Build and Tag with SHA
    uses: ./.github/workflows/docker-build.yml
    with:
      environment: production
      image_tag: ${{ github.sha }}
    secrets:
      AZURE_CREDENTIALS: ${{ secrets.AZURE_CREDENTIALS }}
      AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      ACR_NAME: ${{ secrets.ACR_NAME }}

  deploy-infrastructure:
    name: Deploy Azure Infrastructure
    runs-on: ubuntu-latest
    needs: [build-image, build-sha-image]
    environment: production  # Requires manual approval
    outputs:
      app_url: ${{ steps.get-url.outputs.app_url }}
      app_insights_connection_string: ${{ steps.deploy.outputs.appInsightsConnectionString }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set Azure Subscription
        run: az account set --subscription ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Deploy Bicep template
        id: deploy
        run: |
          echo "üöÄ Deploying infrastructure to production..."
          echo "üì¶ Release: ${{ github.event.release.tag_name || inputs.release_tag }}"

          DEPLOYMENT_OUTPUT=$(az deployment group create \
            --resource-group ${{ secrets.RESOURCE_GROUP }} \
            --template-file infra/main.bicep \
            --parameters infra/parameters/production.bicepparam \
            --parameters imageTag=${{ github.event.release.tag_name || inputs.release_tag }} \
            --output json)

          echo "‚úÖ Infrastructure deployment completed"

          # Extract outputs
          APP_FQDN=$(echo $DEPLOYMENT_OUTPUT | jq -r '.properties.outputs.appFqdn.value')
          APP_INSIGHTS_CONN=$(echo $DEPLOYMENT_OUTPUT | jq -r '.properties.outputs.appInsightsConnectionString.value')

          echo "app_fqdn=${APP_FQDN}" >> $GITHUB_OUTPUT
          echo "appInsightsConnectionString=${APP_INSIGHTS_CONN}" >> $GITHUB_OUTPUT

          echo "üìç App URL: https://${APP_FQDN}"

      - name: Get Container App URL
        id: get-url
        run: |
          APP_FQDN=$(az containerapp show \
            --name ${{ secrets.APP_NAME }} \
            --resource-group ${{ secrets.RESOURCE_GROUP }} \
            --query properties.configuration.ingress.fqdn -o tsv)

          APP_URL="https://${APP_FQDN}"
          echo "app_url=${APP_URL}" >> $GITHUB_OUTPUT
          echo "üìç Container App URL: ${APP_URL}"

      - name: Verify resources deployed
        run: |
          echo "Verifying deployed resources..."
          az resource list \
            --resource-group ${{ secrets.RESOURCE_GROUP }} \
            --output table

  populate-secrets:
    name: Populate Key Vault Secrets
    runs-on: ubuntu-latest
    needs: deploy-infrastructure
    environment: production

    steps:
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set Azure Subscription
        run: az account set --subscription ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Set Salesforce secrets
        run: |
          echo "üîê Populating Key Vault secrets..."

          # Set SF_CLIENT_ID
          az keyvault secret set \
            --vault-name ${{ secrets.KEY_VAULT_NAME }} \
            --name SF-CLIENT-ID \
            --value "${{ secrets.SF_CLIENT_ID }}" \
            --output none
          echo "‚úÖ SF-CLIENT-ID set"

          # Set SF_USERNAME
          az keyvault secret set \
            --vault-name ${{ secrets.KEY_VAULT_NAME }} \
            --name SF-USERNAME \
            --value "${{ secrets.SF_USERNAME }}" \
            --output none
          echo "‚úÖ SF-USERNAME set"

          # Set SF_DOMAIN
          az keyvault secret set \
            --vault-name ${{ secrets.KEY_VAULT_NAME }} \
            --name SF-DOMAIN \
            --value "${{ secrets.SF_DOMAIN }}" \
            --output none
          echo "‚úÖ SF-DOMAIN set"

      - name: Set SF_PRIVATE_KEY secret
        run: |
          # Create temp file for private key
          echo "${{ secrets.SF_PRIVATE_KEY }}" > /tmp/sf_private_key.pem

          # Set private key from file
          az keyvault secret set \
            --vault-name ${{ secrets.KEY_VAULT_NAME }} \
            --name SF-PRIVATE-KEY \
            --file /tmp/sf_private_key.pem \
            --output none

          # Clean up temp file
          rm /tmp/sf_private_key.pem
          echo "‚úÖ SF-PRIVATE-KEY set"

      - name: Set Application Insights connection string
        run: |
          # Get App Insights connection string from deployment output
          CONN_STRING=$(az monitor app-insights component show \
            --app docgen-production-insights \
            --resource-group ${{ secrets.RESOURCE_GROUP }} \
            --query connectionString -o tsv)

          az keyvault secret set \
            --vault-name ${{ secrets.KEY_VAULT_NAME }} \
            --name AZURE-MONITOR-CONNECTION-STRING \
            --value "${CONN_STRING}" \
            --output none
          echo "‚úÖ AZURE-MONITOR-CONNECTION-STRING set"

      - name: Verify secrets
        run: |
          echo "Verifying Key Vault secrets..."
          az keyvault secret list \
            --vault-name ${{ secrets.KEY_VAULT_NAME }} \
            --query "[].{Name:name, Enabled:attributes.enabled}" \
            --output table

  update-app:
    name: Update Container App
    runs-on: ubuntu-latest
    needs: [build-image, deploy-infrastructure, populate-secrets]
    environment: production
    outputs:
      revision_name: ${{ steps.update.outputs.revision_name }}
      previous_revision: ${{ steps.get-current.outputs.current_revision }}

    steps:
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set Azure Subscription
        run: az account set --subscription ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Get current active revision
        id: get-current
        run: |
          CURRENT_REV=$(az containerapp revision list \
            --name ${{ secrets.APP_NAME }} \
            --resource-group ${{ secrets.RESOURCE_GROUP }} \
            --query "[?properties.active==\`true\`].name | [0]" -o tsv)

          echo "current_revision=${CURRENT_REV}" >> $GITHUB_OUTPUT
          echo "üìå Current active revision: ${CURRENT_REV}"

      - name: Update Container App with new image
        id: update
        run: |
          echo "üîÑ Updating Container App with release: ${{ github.event.release.tag_name || inputs.release_tag }}"
          echo "üì¶ Image URI: ${{ needs.build-image.outputs.image_uri }}"

          az containerapp update \
            --name ${{ secrets.APP_NAME }} \
            --resource-group ${{ secrets.RESOURCE_GROUP }} \
            --image ${{ needs.build-image.outputs.image_uri }} \
            --output none

          echo "‚úÖ Container App updated"

      - name: Wait for new revision to be ready
        id: wait-revision
        run: |
          echo "‚è≥ Waiting for new revision to become active..."

          MAX_ATTEMPTS=30
          SLEEP_SECONDS=10
          ATTEMPT=0

          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            REVISION_STATUS=$(az containerapp revision list \
              --name ${{ secrets.APP_NAME }} \
              --resource-group ${{ secrets.RESOURCE_GROUP }} \
              --query "[?properties.active==\`true\`] | [0].properties.provisioningState" -o tsv)

            echo "Attempt $((ATTEMPT+1))/$MAX_ATTEMPTS: Revision status: ${REVISION_STATUS}"

            if [ "$REVISION_STATUS" == "Provisioned" ]; then
              NEW_REV=$(az containerapp revision list \
                --name ${{ secrets.APP_NAME }} \
                --resource-group ${{ secrets.RESOURCE_GROUP }} \
                --query "[?properties.active==\`true\`].name | [0]" -o tsv)

              echo "revision_name=${NEW_REV}" >> $GITHUB_OUTPUT
              echo "‚úÖ New revision is active: ${NEW_REV}"
              exit 0
            fi

            ATTEMPT=$((ATTEMPT+1))
            sleep $SLEEP_SECONDS
          done

          echo "‚ùå Timeout waiting for revision to become active"
          exit 1

      - name: Show revision details
        run: |
          echo "üìã Active revisions:"
          az containerapp revision list \
            --name ${{ secrets.APP_NAME }} \
            --resource-group ${{ secrets.RESOURCE_GROUP }} \
            --query "[?properties.active==\`true\`].{Name:name, Created:properties.createdTime, Replicas:properties.replicas, Traffic:properties.trafficWeight}" \
            --output table

  smoke-tests:
    name: Run Smoke Tests
    runs-on: ubuntu-latest
    needs: [deploy-infrastructure, update-app]
    environment: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Wait for app to be ready
        run: |
          echo "‚è≥ Waiting for app to be fully ready..."
          sleep 30

      - name: Test /healthz endpoint
        run: |
          echo "üè• Testing health endpoint..."
          APP_URL="${{ needs.deploy-infrastructure.outputs.app_url }}"

          RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" ${APP_URL}/healthz)

          if [ "$RESPONSE" != "200" ]; then
            echo "‚ùå Health check failed with status: ${RESPONSE}"
            exit 1
          fi

          echo "‚úÖ Health check passed"

      - name: Test /readyz endpoint
        run: |
          echo "üîç Testing readiness endpoint..."
          APP_URL="${{ needs.deploy-infrastructure.outputs.app_url }}"

          RESPONSE=$(curl -s ${APP_URL}/readyz)
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" ${APP_URL}/readyz)

          if [ "$HTTP_CODE" != "200" ]; then
            echo "‚ùå Readiness check failed with status: ${HTTP_CODE}"
            echo "Response: ${RESPONSE}"
            exit 1
          fi

          echo "‚úÖ Readiness check passed"
          echo "Response: ${RESPONSE}"

      - name: Test document generation (5 times)
        run: |
          echo "üìÑ Testing document generation (5 iterations)..."
          APP_URL="${{ needs.deploy-infrastructure.outputs.app_url }}"

          SUCCESS_COUNT=0
          TOTAL_TESTS=5

          for i in $(seq 1 $TOTAL_TESTS); do
            echo "Test iteration $i/$TOTAL_TESTS..."

            # Create test payload with unique hash
            cat > /tmp/test-payload-$i.json <<EOF
          {
            "templateId": "068Qy000000L6MNIA0",
            "outputFileName": "Test_Document_$i.pdf",
            "outputFormat": "PDF",
            "locale": "en-GB",
            "timezone": "Europe/London",
            "generatedDocumentId": "a00Qy000000TEST$i",
            "options": {
              "storeMergedDocx": false,
              "returnDocxToBrowser": false
            },
            "parents": {
              "AccountId": "001Qy00000TEST$i",
              "OpportunityId": null,
              "CaseId": null
            },
            "data": {
              "Account": {
                "Name": "Production Smoke Test $i",
                "BillingCity": "London",
                "AnnualRevenue__formatted": "¬£100,000"
              }
            },
            "requestHash": "sha256:prodtest$(date +%s)-$i"
          }
          EOF

            # Test endpoint (will return 401 without AAD token, which is acceptable)
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" \
              -X POST \
              -H "Content-Type: application/json" \
              -d @/tmp/test-payload-$i.json \
              ${APP_URL}/generate)

            # Accept 401 (auth required) or 200 (success)
            if [ "$HTTP_CODE" == "401" ] || [ "$HTTP_CODE" == "200" ]; then
              SUCCESS_COUNT=$((SUCCESS_COUNT+1))
              echo "  ‚úÖ Iteration $i passed (status: ${HTTP_CODE})"
            else
              echo "  ‚ùå Iteration $i failed (status: ${HTTP_CODE})"
            fi

            rm /tmp/test-payload-$i.json
            sleep 2  # Small delay between tests
          done

          echo "Results: $SUCCESS_COUNT/$TOTAL_TESTS tests passed"

          if [ $SUCCESS_COUNT -lt $TOTAL_TESTS ]; then
            echo "‚ùå Some smoke tests failed"
            exit 1
          fi

          echo "‚úÖ All smoke tests passed"

      - name: Test worker endpoints
        run: |
          echo "üîß Testing worker endpoints..."
          APP_URL="${{ needs.deploy-infrastructure.outputs.app_url }}"

          # Test worker status endpoint (requires AAD auth, will return 401)
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" ${APP_URL}/worker/status)

          # Accept 401 (auth required) or 200 (success)
          if [ "$HTTP_CODE" != "401" ] && [ "$HTTP_CODE" != "200" ]; then
            echo "‚ùå Worker status endpoint failed: ${HTTP_CODE}"
            exit 1
          fi

          echo "‚úÖ Worker status endpoint responding (status: ${HTTP_CODE})"

      - name: Summary
        run: |
          echo "üéâ All smoke tests passed!"
          echo "üìç App URL: ${{ needs.deploy-infrastructure.outputs.app_url }}"
          echo "üè∑Ô∏è Release: ${{ github.event.release.tag_name || inputs.release_tag }}"
          echo "üì¶ Revision: ${{ needs.update-app.outputs.revision_name }}"

  rollback:
    name: Rollback on Failure
    runs-on: ubuntu-latest
    needs: [update-app, smoke-tests]
    if: failure()
    environment: production

    steps:
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set Azure Subscription
        run: az account set --subscription ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Get previous revision
        id: get-previous
        run: |
          PREV_REV="${{ needs.update-app.outputs.previous_revision }}"
          echo "previous_revision=${PREV_REV}" >> $GITHUB_OUTPUT
          echo "üîÑ Rolling back to previous revision: ${PREV_REV}"

      - name: Activate previous revision
        run: |
          PREV_REV="${{ steps.get-previous.outputs.previous_revision }}"

          if [ -z "$PREV_REV" ] || [ "$PREV_REV" == "null" ]; then
            echo "‚ö†Ô∏è No previous revision found, cannot rollback"
            exit 1
          fi

          echo "üîÑ Activating previous revision: ${PREV_REV}"

          az containerapp revision activate \
            --name ${{ secrets.APP_NAME }} \
            --resource-group ${{ secrets.RESOURCE_GROUP }} \
            --revision ${PREV_REV}

          echo "‚úÖ Rollback completed successfully"

      - name: Verify rollback
        run: |
          echo "üîç Verifying rollback..."

          ACTIVE_REV=$(az containerapp revision list \
            --name ${{ secrets.APP_NAME }} \
            --resource-group ${{ secrets.RESOURCE_GROUP }} \
            --query "[?properties.active==\`true\`].name | [0]" -o tsv)

          echo "üìå Active revision after rollback: ${ACTIVE_REV}"

          # Test health endpoint
          APP_URL=$(az containerapp show \
            --name ${{ secrets.APP_NAME }} \
            --resource-group ${{ secrets.RESOURCE_GROUP }} \
            --query properties.configuration.ingress.fqdn -o tsv)

          sleep 15  # Wait for rollback to stabilize

          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" https://${APP_URL}/healthz)

          if [ "$HTTP_CODE" != "200" ]; then
            echo "‚ùå Health check failed after rollback: ${HTTP_CODE}"
            exit 1
          fi

          echo "‚úÖ Rollback verified, app is healthy"

      - name: Deactivate failed revision
        run: |
          FAILED_REV="${{ needs.update-app.outputs.revision_name }}"

          if [ -n "$FAILED_REV" ] && [ "$FAILED_REV" != "null" ]; then
            echo "üóëÔ∏è Deactivating failed revision: ${FAILED_REV}"

            az containerapp revision deactivate \
              --name ${{ secrets.APP_NAME }} \
              --resource-group ${{ secrets.RESOURCE_GROUP }} \
              --revision ${FAILED_REV} || true

            echo "‚úÖ Failed revision deactivated"
          fi

      - name: Notify rollback
        uses: actions/github-script@v7
        with:
          script: |
            const comment = `## ‚ö†Ô∏è Production Deployment Failed - Rollback Executed

            **Release:** ${{ github.event.release.tag_name || inputs.release_tag }}
            **Rolled back to:** \`${{ needs.update-app.outputs.previous_revision }}\`

            The deployment to production failed smoke tests and has been automatically rolled back to the previous revision.

            **Action Required:**
            1. Review workflow logs: [Run #${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
            2. Investigate the failure cause
            3. Fix the issue and create a new release

            **App URL:** ${{ needs.deploy-infrastructure.outputs.app_url }}
            `;

            github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: comment
            });

  summary:
    name: Deployment Summary
    runs-on: ubuntu-latest
    needs: [build-image, deploy-infrastructure, update-app, smoke-tests]
    if: always()
    environment: production

    steps:
      - name: Post deployment summary
        uses: actions/github-script@v7
        with:
          script: |
            const deploymentStatus = '${{ needs.smoke-tests.result }}';
            const statusEmoji = deploymentStatus === 'success' ? '‚úÖ' : '‚ùå';
            const statusText = deploymentStatus === 'success' ? 'SUCCESS' : 'FAILED';

            const summary = `## ${statusEmoji} Production Deployment ${statusText}

            **Release:** ${{ github.event.release.tag_name || inputs.release_tag }}
            **Deployed by:** @${{ github.actor }}
            **App URL:** ${{ needs.deploy-infrastructure.outputs.app_url }}

            ### Deployment Details
            - **Release Tag:** \`${{ github.event.release.tag_name || inputs.release_tag }}\`
            - **Commit SHA:** \`${{ github.sha }}\`
            - **Image URI:** \`${{ needs.build-image.outputs.image_uri }}\`
            - **Revision:** \`${{ needs.update-app.outputs.revision_name }}\`
            - **Resource Group:** \`${{ secrets.RESOURCE_GROUP }}\`
            - **Container App:** \`${{ secrets.APP_NAME }}\`

            ### Job Results
            - Build Image: ${{ needs.build-image.result }}
            - Deploy Infrastructure: ${{ needs.deploy-infrastructure.result }}
            - Update App: ${{ needs.update-app.result }}
            - Smoke Tests: ${{ needs.smoke-tests.result }}

            ### Smoke Test Results
            - Health Check: ‚úÖ
            - Readiness Check: ‚úÖ
            - Document Generation (5x): ‚úÖ
            - Worker Endpoints: ‚úÖ

            **Workflow Run:** [#${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})

            **Deployment Time:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")
            `;

            // Post as release comment if this is a release deployment
            if (context.payload.release) {
              github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.release.id,
                body: summary
              });
            }
